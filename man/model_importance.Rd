% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_importance.R
\name{model_importance}
\alias{model_importance}
\title{Quantify overall contributions of ensemble component model to ensemble
prediction accuracy}
\usage{
model_importance(
  forecast_data,
  oracle_output_data,
  ensemble_fun = c("simple_ensemble", "linear_pool"),
  weighted = FALSE,
  training_window_length = 0,
  importance_algorithm = c("lomo", "lasomo"),
  subset_wt = c("equal", "perm_based"),
  na_action = c("worst", "average", "drop"),
  ...
)
}
\arguments{
\item{forecast_data}{A data.frame with the predictions that is or can be
coerced to a model_out_tbl format. Only one \code{output_type} is allowed in the
data.frame, and it must be one of the following:
\code{mean}, \code{median}, \code{quantile}, or \code{pmf}.}

\item{oracle_output_data}{Ground truth data for the variables that are used
to define modeling targets. This data must follow the oracle output format.
See 'Details'.}

\item{ensemble_fun}{A character string specifying a ensemble method, either
"simple_ensemble" or "linear_pool"; \code{c("simple_ensemble", "linear_pool")}.
\itemize{
\item When \code{"simple_ensemble"} is specified, the ensemble is generated using the
optional \code{agg_fun} function in \code{...} (see 'Details').
\item When \code{"linear_pool"} is specified, ensemble model outputs are created as
a linear pool of component model outputs. This method supports only
an \code{output_type} of \code{mean}, \code{quantile}, or \code{pmf}.
}}

\item{weighted}{Boolean indicating whether model weighting should be done
when building an ensemble using the \code{ensemble_fun}.
\itemize{
\item If \code{FALSE}, all models are given equal weight.
\item If \code{TRUE}, model weights are estimated.
}}

\item{training_window_length}{An integer value representing the time interval
of historical data used during the training process
to estimate model weights.
Default is \code{0}, meaning that no prior data is available for training.}

\item{importance_algorithm}{A character string specifying algorithm for model
importance calculation; \code{c("lomo", "lasomo")}.
\code{"lomo"} stands for leave-one-model-out and
\code{"lasomo"} stands for leave all subsets of models out.}

\item{subset_wt}{A character string specifying method for assigning weight
to subsets when using \code{lasomo} algorithm; \code{c("equal", "perm_based")}.
\itemize{
\item \code{"equal"} assigns equal weight to all subsets.
\item \code{"perm_based"} assigns weight averaged over all possible permutations as in
the Shapley value.
}}

\item{na_action}{A character string specifying treatment for missing data;
\verb{c("worst," "average," "drop").}
\itemize{
\item \code{"worst"} replaces missing values with the smallest value from the other
models.
\item \code{"average"} replaces missing values with the average value from the other
models.
\item \code{"drop"} removes missing values.
}}

\item{...}{Optional arguments passed to \code{ensemble_fun} when it is specified
as \code{"simple_ensemble"}. See 'Details'.}
}
\value{
A data.frame with columns
\code{task_id}, \code{output_type}, \code{model_id}, \code{importance_score}.
}
\description{
Evaluate ensemble component model's importance based on a measure of their
contribution to ensemble prediction accuracy for each combination of
model task.

For each \code{output_type}, the corresponding scoring rule applied to calculate
the importance is as follows.
\tabular{ll}{
\strong{Output Type} \tab \strong{Scoring Rule} \cr
median \tab ae_point \cr
mean \tab se_point \cr
quantile \tab wis \cr
pmf \tab log_score \cr
}
where \code{ae_point} represents the absolute error, \code{se_point} the squared error,
\code{wis} the weighted interval score, and \code{log_score} the logarithmic score.
}
\details{
The \code{oracle_output_data} in the oracle output format should contain
independent task ID columns (e.g. \code{location}, \code{target_date}, and \code{age_group})
, \code{output_type} and \code{output_type_id} columns if the output is either \code{pmf} or
\code{cdf}, and \code{oracle_value} column for the observed values.
TBD for more details.

Additional argument in \code{...} is \code{agg_fun}, which is a character string name
for a function specifying aggregation method of component model outputs.
Default is \code{mean}, meaning that equally (or weighted) mean is calculated
across all component model outputs for each unique \code{output_type_id}.
This can be \code{median} or a custom function (e.g., geometric_mean. Details
can be found in
https://hubverse-org.github.io/hubEnsembles/articles/hubEnsembles.html)
}
\examples{
\dontrun{
library(dplyr)
library(hubExamples)
forecast_data <- hubExamples::forecast_outputs |>
  dplyr::filter(
    output_type \%in\% c("quantile"),
    location == "25",
    horizon == 1
  )
target_data <- hubExamples::forecast_target_ts |>
  dplyr::filter(
    date \%in\% unique(forecast_data$target_end_date),
    location == "25"
  ) |>
  # Rename columns to match the oracle output format
  rename(
    target_end_date = date,
    oracle_value = observation
  )
# Example with the default arguments.
model_importance(
  forecast_data = forecast_data, oracle_output_data = target_data,
  ensemble_fun = "simple_ensemble", weighted = FALSE,
  training_window_length = 0, importance_algorithm = "lomo",
  subset_wt = "equal", na_action = "drop"
)
# Example with the additional argument in `...`.
model_importance(
  forecast_data = forecast_data, oracle_output_data = target_data,
  ensemble_fun = "simple_ensemble", weighted = FALSE,
  training_window_length = 0, importance_algorithm = "lomo",
  subset_wt = "equal", na_action = "drop",
  agg_fun = median
)
}
}
