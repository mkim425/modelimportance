% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_importance.R
\name{model_importance}
\alias{model_importance}
\title{Quantify ensemble component model contributions to ensemble
prediction accuracy}
\usage{
model_importance(
  forecast_data,
  target_data,
  ensemble_fun = c("simple_ensemble", "linear_pool"),
  weighted = FALSE,
  training_window_length = 0,
  importance_algorithm = c("lomo", "lasomo"),
  subset_wt = c("equal", "perm_based"),
  scoring_rule = c("ae_point", "se_point", "wis", "logscore"),
  na_action = c("worst", "average", "drop"),
  ...
)
}
\arguments{
\item{forecast_data}{A data.frame with the predictions that is or can be
coerced to a model_out_tbl format.}

\item{target_data}{Ground truth data for the variables that are used to
define modeling targets. This data must follow the oracle output format.
See 'Details'.}

\item{ensemble_fun}{A character string specifying a ensemble method, either
"simple_ensemble" or "linear_pool"; `c("simple_ensemble", "linear_pool")`.
* When `"simple_ensemble"` is specified, the ensemble is generated using the
optional `agg_fun` function in `...` (see 'Details'). It takes into account
the weight option specified in `weighted`.
* When `"linear_pool"` is specified, ensemble model outputs are created as
a linear pool of component model outputs. This method supports only
an `output_type` of `mean`, `quantile`, or `pmf`.}

\item{weighted}{Boolean indicating whether model weighting should be done.
If `FALSE`, all models are given equal weight.
If `TRUE`, model weights are estimated.}

\item{training_window_length}{An integer value representing the time interval
of historical data used during the training process
to estimate model weights.
Default is `0`, meaning that no prior data is available for training.}

\item{importance_algorithm}{A character string specifying algorithm for model
importance calculation; `c("lomo", "lasomo")`.
`"lomo"` stands for leave-one-model-out and
`"lasomo"` stands for leave all subsets of models out.}

\item{subset_wt}{A character string specifying method for assigning weight
to subsets when using `lasomo` algorithm; `c("equal", "perm_based")`.}

\item{scoring_rule}{A character string specifying metric to use to calculate
importance; `c("ae_point", "se_point", "wis", "logscore")`.
Specify one of them depending on which is available for the output type in
the input data.}

\item{na_action}{A character string specifying treatment for missing data;
`c("worst," "average," "drop").` `"worst"` replaces missing values with
the smallest value from the other models. `"average"` replaces
missing values with the average value from the other models.
`"drop"` removes missing values.}

\item{...}{Optional arguments passed to `ensemble_fun` when it is specified
as `"simple_ensemble"`. See 'Details'.}
}
\value{
A data.frame with columns
`task_id`, `output_type`, `model`, `importance_score`.
}
\description{
Evaluate ensemble component model's importance based on a measure of their
contribution to ensemble prediction accuracy for each combination of
model task.
}
\details{
The `target_data` in the oracle output format should contain independent
task ID columns (e.g. `location`, `target_date`, and `age_group`),
`output_type` and `output_type_id` columns if the output is either `pmf` or
`cdf`, and `oracle_value` column for the observed values.
TBD for more details.

Additional argument in ... is `agg_fun`, which is a character string name
for a function specifying aggregation method of component model outputs.
Default is `mean`, meaning that equally (or weighted) mean is calculated
across all component model outputs for each unique `output_type_id`.
This can be `median` or a custom function (e.g., geometric_mean. Details
can be found in
https://hubverse-org.github.io/hubEnsembles/articles/hubEnsembles.html)
}
\examples{
\dontrun{
library(dplyr)
library(hubExamples)
forecast_data <- hubExamples::forecast_outputs |>
  dplyr::filter(
    output_type \%in\% c("quantile"),
    location == "25",
    horizon == 1
  )
target_data <- hubExamples::forecast_target_ts |>
  dplyr::filter(
    date \%in\% unique(forecast_data$reference_date),
    location == "25"
  )

model_importance(
  forecast_data = forecast_data, target_data = target_data,
  ensemble_fun = "simple_ensemble", weighted = FALSE,
  training_window_length = 0, importance_algorithm = "lomo",
  subset_wt = "equal", scoring_rule = "wis", na_action = "drop"
)
# Example with the additional argument in `...`.
model_importance(
  forecast_data = forecast_data, target_data = target_data,
  ensemble_fun = "simple_ensemble", weighted = FALSE,
  training_window_length = 0, importance_algorithm = "lomo",
  subset_wt = "equal", scoring_rule = "wis", na_action = "drop",
  agg_fun = median
)
}
}
