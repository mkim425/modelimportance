% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_importance.R
\name{model_importance}
\alias{model_importance}
\title{Quantify overall contributions of ensemble component model to ensemble
prediction accuracy across multiple forecast tasks}
\usage{
model_importance(
  forecast_data,
  oracle_output_data,
  ensemble_fun = c("simple_ensemble", "linear_pool"),
  importance_algorithm = c("lomo", "lasomo"),
  subset_wt = c("equal", "perm_based"),
  na_action = c("worst", "average", "drop"),
  min_log_score = -10,
  ...
)
}
\arguments{
\item{forecast_data}{A data.frame with the predictions that is or can be
coerced to a \code{model_out_tbl} format, which is the standard S3 class model
output format defined by the 'hubverse' convention
(https://docs.hubverse.io/en/latest/#). If it fails to be coerced to a
\code{model_out_tbl} format, an error message will be returned.
Only one \code{output_type} is allowed in the data.frame, and it must be one of
the following: \code{mean}, \code{median}, \code{quantile}, or \code{pmf}.}

\item{oracle_output_data}{Ground truth data for the variables that are used
to define modeling targets. This data must follow the oracle output format.
See 'Details'.}

\item{ensemble_fun}{A character string specifying a ensemble method, either
"simple_ensemble" or "linear_pool"; \code{c("simple_ensemble", "linear_pool")}.
\itemize{
\item When \code{"simple_ensemble"} is specified, the ensemble is generated using the
optional \code{agg_fun} function in \code{...} (see 'Details').
\item When \code{"linear_pool"} is specified, ensemble model outputs are created as
a linear pool of component model outputs. This method supports only
an \code{output_type} of \code{mean}, \code{quantile}, or \code{pmf}.
}}

\item{importance_algorithm}{A character string specifying algorithm for model
importance calculation; \code{c("lomo", "lasomo")}.
\code{"lomo"} stands for leave-one-model-out and
\code{"lasomo"} stands for leave all subsets of models out.
For \code{"lasomo"}, \code{'furrr'} and \code{'future'} packages need to be installed for
parallel execution.}

\item{subset_wt}{A character string specifying method for assigning weight
to subsets when using \code{lasomo} algorithm; \code{c("equal", "perm_based")}.
\itemize{
\item \code{"equal"} assigns equal weight to all subsets.
\item \code{"perm_based"} assigns weight averaged over all possible permutations as in
the Shapley value.
Ignored if \code{lomo} method is used. Default is \code{"equal"}, if not specified.
}}

\item{na_action}{A character string specifying how to handle \code{NA} values
generated during importance score calculation for each task, occurring when a
model did not contribute to the ensemble prediction for a given task by
missing its forecast submission.
Three options are available: \code{c("worst", "average", "drop")}.
For each specific prediction task, each option works as follows:
\itemize{
\item \code{"worst"} replaces \code{NA}s with the smallest value among importance metrics
of the other models.
\item \code{"average"} replaces \code{NA}s with the average value from the other
models' importance metrics.
\item \code{"drop"} removes \code{NA}s.
}}

\item{min_log_score}{A numeric value specifying a minimum threshold for log
scores for the \code{pmf} output to avoid issues with extremely low probabilities
assigned to the true outcome, which can lead to undefined or negative
infinite log scores. Any probability lower than this threshold will be
adjusted to this minimum value. The default value is set to -10, which is an
arbitrary choice. Users may choose a different value based on their practical
needs.}

\item{...}{Optional arguments passed to \code{ensemble_fun} when it is specified
as \code{"simple_ensemble"}. See 'Details'.}
}
\value{
A data.frame with columns
\code{task_id}, \code{output_type}, \code{model_id}, \code{importance_score}.
}
\description{
We measure each ensemble component model's contribution to the ensemble
prediction accuracy for each model task. Then, we aggregate the contributions
across all tasks to quantify each component model's overall importance.

This function requires that one column represent the forecast date (or
a date from which each forecast originates or is made in reference to) and
that column be named one of \code{forecast_date}, \code{origin_date}, and
\code{reference_date}.

For each \code{output_type}, the corresponding scoring rule applied to calculate
the importance is as follows.

\tabular{lll}{
\strong{Output Type} \tab \strong{Scoring Rule} \tab \strong{Description}
\cr
mean \tab rse_point \tab evaluate using the root squared error \cr
median \tab ae_point\tab evaluate using the absolute error \cr
quantile \tab wis \tab evaluate using the weighted interval score\cr
pmf \tab log_score \tab
{evaluate using the logarithm of the probability assigned to the true
outcome} \cr
}
}
\details{
The \code{oracle_output_data} is a data frame that contains the ground truth
values for the variables used to define modeling targets. It is referred to
as “oracle” because it is formatted as if an oracle made a perfect point
prediction equal to the truth. This data must follow the oracle output format
defined in the hubverse standard, which includes independent task ID columns
(e.g., \code{location}, \code{target_date}), the \code{output_type} column specifying the
output type of the predictions and an \code{oracle_value} column for the observed
values. As in the forecast data, if the \code{output_type} is either \code{"quantile"}
or \code{"pmf"}, the \code{output_type_id} column is often required to provide further
identifying information.

The \code{model_out_tbl} and \code{oracle_output_data} must have the same task ID
columns and \code{output_type}, including \code{output_type_id} if necessary, which are
used to match the predictions with the ground truth data.

Additional argument in \code{...} is \code{agg_fun}, which is a character string name
for a function specifying aggregation method of component model outputs.
Default is \code{mean}, indicating that equally weighted mean is calculated
across all component model outputs for each unique \code{output_type_id}.
This can be \code{median} or a custom function (e.g., geometric_mean. Details
can be found in
https://hubverse-org.github.io/hubEnsembles/articles/hubEnsembles.html).

This function uses the \code{furrr} and \code{future} for parallelization.
To enable parallel execution, please set a parallel backend, e.g., via
\code{future::plan()}.
}
\examples{
\dontrun{
library(dplyr)
library(hubExamples)
forecast_data <- hubExamples::forecast_outputs |>
  dplyr::filter(
    output_type \%in\% c("quantile"),
    location == "25",
    horizon == 1
  )
target_data <- hubExamples::forecast_target_ts |>
  dplyr::filter(
    date \%in\% unique(forecast_data$target_end_date),
    location == "25"
  ) |>
  # Rename columns to match the oracle output format
  rename(
    target_end_date = date,
    oracle_value = observation
  )
# Example with the default arguments.
model_importance(
  forecast_data = forecast_data, oracle_output_data = target_data,
  ensemble_fun = "simple_ensemble", importance_algorithm = "lomo",
  subset_wt = "equal", na_action = "drop"
)
# Example with the additional argument in `...`.
model_importance(
  forecast_data = forecast_data, oracle_output_data = target_data,
  ensemble_fun = "simple_ensemble", importance_algorithm = "lomo",
  subset_wt = "equal", na_action = "drop",
  agg_fun = median
)
}
}
